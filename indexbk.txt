<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Stress Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 1000px;
      margin: 2rem auto;
      padding: 0 1rem;
      background: #0f172a;
      color: #e5e7eb;
    }

    .running-indicator {
      animation: pulse 1.2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.6; }
      100% { opacity: 1; }
    }

    .collapsible-header {
      display: flex;
      align-items: center;
      cursor: pointer;
      user-select: none;
    }
    
    .collapsible-header::after {
      content: "‚ñæ";
      margin-left: auto;
      font-size: 0.8rem;
      opacity: 0.7;
      transition: transform 0.2s ease;
    }
    
    .collapsible-header.collapsed::after {
      transform: rotate(-90deg);
    }
    
    .collapsible-content.hidden {
      display: none;
    }
    
    .panel {
      background: #0f172a;
      border: 1px solid #1e293b;
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1.25rem;
    }
    
    .panel h2 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1.05rem;
      color: #e5e7eb;
    }

    .chart-box {
      background: #020617;
      border: 1px solid #1f2937;
      border-radius: 10px;
      padding: 0.6rem 0.6rem 0.4rem;
    }
    
    .chart-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #9ca3af;
      margin-bottom: 0.3rem;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 1rem;
    }
    .card {
      background: #111827;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      margin-bottom: 1.5rem;
      border: 1px solid #1f2937;
    }
    label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.3rem;
      color: #9ca3af;
    }
    input, select {
      width: 100%;
      padding: 0.5rem 0.6rem;
      border-radius: 8px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      margin-bottom: 0.8rem;
      box-sizing: border-box;
    }
    input:focus, select:focus {
      outline: none;
      border-color: #22c55e;
      box-shadow: 0 0 0 1px #22c55e44;
    }
    button {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.6rem 1.2rem;
      border-radius: 999px;
      border: none;
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, box-shadow 0.05s ease, background 0.1s ease;
    }
    button:hover {
      background: #16a34a;
      box-shadow: 0 10px 25px rgba(34,197,94,0.25);
      transform: translateY(-1px);
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 1rem;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    .metric {
      background: #020617;
      border-radius: 10px;
      padding: 0.6rem 0.8rem;
      border: 1px solid #1f2937;
    }
    .metric-label {
      font-size: 0.75rem;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 0.2rem;
    }
    .metric-value {
      font-size: 0.95rem;
      font-weight: 600;
    }
    .status-codes {
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    .status-pill {
      display: inline-block;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #1f2937;
      margin-right: 0.4rem;
      margin-bottom: 0.4rem;
      font-size: 0.8rem;
    }
    .status-pill.ok {
      border-color: #22c55e55;
      color: #bbf7d0;
    }
    .status-pill.err {
      border-color: #ef444455;
      color: #fecaca;
    }
    pre {
      background: #020617;
      padding: 0.75rem;
      border-radius: 10px;
      border: 1px solid #1f2937;
      font-size: 0.8rem;
      overflow-x: auto;
    }
    .small {
      font-size: 0.8rem;
      color: #6b7280;
      margin-top: 0.3rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }
    th, td {
      padding: 0.5rem 0.4rem;
      text-align: left;
      border-bottom: 1px solid #1f2937;
    }
    th {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
    }
    tr:hover {
      background: #020617;
      cursor: pointer;
    }
    .badge {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #374151;
      font-size: 0.75rem;
    }
    .badge.method {
      border-color: #38bdf855;
      color: #bae6fd;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>API Stress Lab</h1>

  <!-- Run Test -->
   <section class="panel">
  <div class="card">
    <h2 style="margin-top:0;margin-bottom:0.8rem;">Run a Load Test</h2>
    <form id="test-form">
      <label for="url">Target URL</label>
      <input
        id="url"
        name="url"
        type="url"
        required
        value="https://httpbin.org/get"
      />

      <div class="row">
        <div>
          <label for="method">HTTP Method</label>
          <select id="method" name="method">
            <option>GET</option>
            <option>POST</option>
            <option>PUT</option>
            <option>DELETE</option>
            <option>PATCH</option>
            <option>HEAD</option>
            <option>OPTIONS</option>
          </select>
        </div>
        <div>
          <label for="requests">Total Requests</label>
          <input id="requests" name="requests" type="number" min="1" max="1000" value="20" />
        </div>
      </div>

      <div class="row">
        <div>
          <label for="concurrency">Concurrency</label>
          <input id="concurrency" name="concurrency" type="number" min="1" max="200" value="5" />
        </div>
        <div>
            <label for="label">Label (optional)</label>
            <input id="label" name="label" type="text" placeholder="e.g. httpbin smoke" />
          </div>
      </div>

      <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;">
        <button type="submit" id="run-btn">
          <span id="btn-label">Run test</span>
          <span id="btn-spinner" style="display:none;">‚è≥</span>
        </button>
      
        <button type="button" id="run-live-btn">
          <span id="live-btn-label">Run live (WebSocket)</span>
          <span id="live-btn-spinner" style="display:none;">üì°</span>
        </button>
      </div>
      <div class="small">
        Be nice ‚Äì don‚Äôt spam APIs you don‚Äôt own.
      </div>
      
    </form>
  </div>
</section>

  <!-- Past Runs -->
   <section class="panel">
  <div class="card" id="tests-card" style="display:none;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.6rem;">
      <h2 class="collapsible-header" data-target="past-runs" style="margin:0;">Past Runs</h2>
      <button id="refresh-tests-btn" type="button" style="padding:0.25rem 0.7rem;font-size:0.78rem;">
        Refresh
      </button>
    </div>
    <div id="past-runs" class="collapsible-content hidden">
    <div class="small" style="margin-bottom:0.5rem;">
      Click a row to view full metrics.
    </div>
    <div id="tests-empty" class="small" style="display:none;">No tests yet. Run one above.</div>
    <div style="overflow-x:auto;">
      <table id="tests-table" style="display:none;">
        <thead>
          <tr>
            <th>ID</th>
            <th>Target</th>
            <th>Method</th>
            <th>Req / Concurrency</th>
            <th>Created at</th>
            <th>Label</th>
          </tr>
        </thead>
        <tbody id="tests-body"></tbody>
      </table>
    </div>
    </div>
  </div>
</section>
  <!-- Results -->
  <section class="panel">
  <div class="card" id="results-card" style="display:none;">
    <h2 style="margin-top:0;margin-bottom:0.5rem;">Results</h2>
    <div id="live-progress" class="small" style="min-height:1.2rem;"></div>
    <div id="summary"></div>
  </section>
    <!-- LIVE CHARTS -->
     <section class="panel">
      <h2 class = "collapsible-header" data-target="live-monitoring" style="margin-top:0.5rem;margin-bottom:0.6rem;font-size:1rem;letter-spacing:0.04em;text-transform:uppercase;color:#cbd5f5;">
        Live Monitoring
      </h2>
      <div id="live-monitoring" class="collapsible-content hidden">
      <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:1rem;margin-bottom:0.75rem;">
      <div class="chart-box">
        <div>
          <div class="metric-label">Latency over time (ms)</div>
          <canvas id="liveLatencyChart" height="160"></canvas>
        </div>
      </div>

      <div class="chart-box">
        <div>
          <div class="metric-label">Requests completed</div>
          <canvas id="liveProgressChart" height="160"></canvas>
        </div>
      </div>
      </div>
    </div>
    </section>
    <section class="panel">
      <h2 class="collapsible-header" data-target="live-throughput" style="margin-top:0.5rem;margin-bottom:0.6rem;font-size:1rem;letter-spacing:0.04em;text-transform:uppercase;color:#cbd5f5;">
        Live Throughput & Errors
      </h2>
      <div id="live-throughput" class="collapsible-content hidden">
        <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:1rem;margin-bottom:0.75rem;">
          <div class="chart-box">
          <div>
            <div class="metric-label">Error Rate (%)</div>
            <canvas id="liveErrorChart" height="160"></canvas>
          </div>
        </div>
        <div class="chart-box">
          <div>
            <div class="metric-label">Requests per Second (RPS)</div>
            <canvas id="liveRpsChart" height="160"></canvas>
          </div>
        </div>
        </div>
      </div>
      </section>
      <!-- STATIC CHARTS -->
      <section class="panel">
        <h2 style="margin-top:0.5rem;margin-bottom:0.6rem;font-size:1rem;letter-spacing:0.04em;text-transform:uppercase;color:#cbd5f5;">
          Latency & Status Code
        </h2>
    <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:1rem;margin-bottom:0.75rem;">
      <div class="chart-box">
        <div class="metric-label" style="margin-bottom:0.3rem;">Latency (ms)</div>
        <canvas id="latencyChart" height="160"></canvas>
      </div>

      <div class="chart-box">
        <div class="metric-label" style="margin-bottom:0.3rem;">Status Codes</div>
        <canvas id="statusChart" height="160"></canvas>
      </div>
    </div>
  </section>
  <section class="panel">
    <h2 class="collapsible-header" data-target="raw-json" style="margin-top:0.5rem;margin-bottom:0.6rem;font-size:1rem;letter-spacing:0.04em;text-transform:uppercase;color:#cbd5f5;">
      Raw JSON
    </h2>
    <div id="raw-json" class="collapsible-content hidden" >
    <pre id="json-output"></pre>
  </div>
  </div>
</section>


  <script>
    const form = document.getElementById("test-form");
    const runBtn = document.getElementById("run-btn");
    const btnLabel = document.getElementById("btn-label");
    const btnSpinner = document.getElementById("btn-spinner");

    const runLiveBtn = document.getElementById("run-live-btn");
    const liveBtnLabel = document.getElementById("live-btn-label");
    const liveBtnSpinner = document.getElementById("live-btn-spinner");
    const liveProgress = document.getElementById("live-progress");


    const resultsCard = document.getElementById("results-card");
    const summaryDiv = document.getElementById("summary");
    const jsonOutput = document.getElementById("json-output");

    const testsCard = document.getElementById("tests-card");
    const testsTable = document.getElementById("tests-table");
    const testsBody = document.getElementById("tests-body");
    const testsEmpty = document.getElementById("tests-empty");
    const refreshTestsBtn = document.getElementById("refresh-tests-btn");

    let isRunning = false;

    let statusChart = null;
    let latencyChart = null;
    let progressChart = null;

    let liveLatencyChart = null;
    let liveProgressChart = null;

    let latencyData = [];
    let progressData = [];
    let timeLabels = [];

    let liveErrorChart = null;
    let liveRpsChart = null;

    let errorRateData = [];
    let rpsData = [];


    let latencyBuffer = [];
    let completedBuffer = [];

    let errorBuffer = [];
    let timestampBuffer = [];


    let chartUpdateTimer = null;
    const CHART_UPDATE_INTERVAL_MS = 200; // 5 updates/sec

    const ROLLING_WINDOW = 10;


    function rollingAverage(arr, windowSize) {
      const slice = arr.slice(-windowSize);
      const sum = slice.reduce((a, b) => a + b, 0);
      return slice.length ? sum / slice.length : 0;
    }

    function setRunningState(running, mode = "normal") {
      isRunning = running;
    
      runBtn.disabled = running;
      runLiveBtn.disabled = running;


      if (running) {
        liveProgress.classList.add("running-indicator");
      } else {
        liveProgress.classList.remove("running-indicator");
      }
  
      // Normal run button
      btnSpinner.style.display = running && mode === "normal" ? "inline" : "none";
      btnLabel.textContent = running && mode === "normal" ? "Running..." : "Run test";
    
      // Live run button
      liveBtnSpinner.style.display = running && mode === "live" ? "inline" : "none";
      liveBtnLabel.textContent =
        running && mode === "live"
          ? "Running live..."
          : "Run live (WebSocket)";
    }
    
    

    function replayTimeSeries(timeseries) {
      if (!timeseries || timeseries.length === 0) return;
    
      initLiveCharts();
      stopChartUpdates();
    
      let prev = null;
    
      timeseries.forEach(point => {
        const label = new Date(point.timestamp * 1000).toLocaleTimeString();
    
        timeLabels.push(label);
        latencyData.push(point.avg_latency_ms ?? 0);
        progressData.push(point.completed ?? 0);
    
        const errorRate =
          point.completed > 0
            ? (point.errors / point.completed) * 100
            : 0;
        errorRateData.push(Number(errorRate.toFixed(2)));
    
        let rps = 0;
        if (prev) {
          const dt = point.timestamp - prev.timestamp;
          const dc = point.completed - prev.completed;
          if (dt > 0) rps = dc / dt;
        }
        rpsData.push(Number(rps.toFixed(2)));
    
        prev = point;
      });
    
      liveLatencyChart.update();
      liveProgressChart.update();
      liveErrorChart.update();
      liveRpsChart.update();
    }
    
    

    function startChartUpdates() {
      stopChartUpdates(); // safety
    
      chartUpdateTimer = setInterval(() => {
        if (!latencyBuffer.length || !completedBuffer.length) return;
    
        const nowLabel = new Date().toLocaleTimeString();
    
        // smooth values
        const smoothedLatency = rollingAverage(latencyBuffer, ROLLING_WINDOW);
        const latestCompleted =
          completedBuffer[completedBuffer.length - 1];
    
        timeLabels.push(nowLabel);
        latencyData.push(Number(smoothedLatency.toFixed(2)));
        progressData.push(latestCompleted);

        // ----- Error Rate (%) -----
        const latestErrors = errorBuffer[errorBuffer.length - 1] ?? 0;
        const errorRate =
          latestCompleted > 0
            ? (latestErrors / latestCompleted) * 100
            : 0;

        errorRateData.push(Number(errorRate.toFixed(2)));

        // ----- RPS -----
        let rps = 0;
        if (timestampBuffer.length >= 2) {
          const n = timestampBuffer.length;
          const dt = timestampBuffer[n - 1] - timestampBuffer[n - 2];
          const dc = completedBuffer[n - 1] - completedBuffer[n - 2];
          if (dt > 0) rps = dc / dt;
        }

        rpsData.push(Number(rps.toFixed(2)));

    
        // keep chart history reasonable
        if (timeLabels.length > 60) {
          timeLabels.shift();
          latencyData.shift();
          progressData.shift();
          errorRateData.shift();
          rpsData.shift();
        }
        
    
        if (liveLatencyChart) liveLatencyChart.update("none");
        if (liveProgressChart) liveProgressChart.update("none");
        if (liveErrorChart) liveErrorChart.update("none");
        if (liveRpsChart) liveRpsChart.update("none");
      }, CHART_UPDATE_INTERVAL_MS);
    }

    function stopChartUpdates() {
      if (chartUpdateTimer) {
        clearInterval(chartUpdateTimer);
        chartUpdateTimer = null;
      }
    }
    
    function initLiveCharts() {
      latencyData = [];
      progressData = [];
      timeLabels = [];
    
      const latencyCtx = document.getElementById("liveLatencyChart")?.getContext("2d");
      const progressCtx = document.getElementById("liveProgressChart")?.getContext("2d");
      const errorCtx = document.getElementById("liveErrorChart")?.getContext("2d");
      const rpsCtx = document.getElementById("liveRpsChart")?.getContext("2d");

      if (!latencyCtx || !progressCtx) return;
    
      if (liveLatencyChart) liveLatencyChart.destroy();
      if (liveProgressChart) liveProgressChart.destroy();
      if (liveErrorChart) liveErrorChart.destroy();
      if (liveRpsChart) liveRpsChart.destroy();
    
      liveLatencyChart = new Chart(latencyCtx, {
        type: "line",
        data: {
          labels: timeLabels,
          datasets: [{
            label: "Avg Latency (ms)",
            data: latencyData,
            borderWidth: 2,
            tension: 0.25,
          }]
        },
        options: {
          animation: false,
          responsive: true,
          scales: {
            y: { beginAtZero: true }
          }
        }
      });
    
      liveProgressChart = new Chart(progressCtx, {
        type: "line",
        data: {
          labels: timeLabels,
          datasets: [{
            label: "Completed Requests",
            data: progressData,
            borderWidth: 2,
            tension: 0.25,
          }]
        },
        options: {
          animation: false,
          responsive: true,
          scales: {
            y: { beginAtZero: true }
          }
        }
      });

      liveErrorChart = new Chart(errorCtx, {
        type: "line",
        data: {
          labels: timeLabels,
          datasets: [{
            label: "Error Rate (%)",
            data: errorRateData,
            borderWidth: 2,
            tension: 0.25,
          }]
        },
        options: {
          animation: false,
          scales: { y: { beginAtZero: true, max: 100 } }
        }
      });
      
      liveRpsChart = new Chart(rpsCtx, {
        type: "line",
        data: {
          labels: timeLabels,
          datasets: [{
            label: "RPS",
            data: rpsData,
            borderWidth: 2,
            tension: 0.25,
          }]
        },
        options: {
          animation: false,
          scales: { y: { beginAtZero: true } }
        }
      });

    }
    
    function updateLatencyChart(lat) {
      const ctx = document.getElementById("latencyChart");
      if (!ctx) return;
    
      const labels = ["avg", "p50", "p90", "p95", "p99"];
      const values = [
        lat.avg ?? 0,
        lat.p50 ?? 0,
        lat.p90 ?? 0,
        lat.p95 ?? 0,
        lat.p99 ?? 0,
      ];
    
      if (latencyChart) {
        latencyChart.data.datasets[0].data = values;
        latencyChart.update();
        return;
      }
    
      latencyChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              label: "Latency (ms)",
              data: values,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              display: false,
            },
          },
          scales: {
            x: {
              ticks: { color: "#9ca3af" },
            },
            y: {
              ticks: { color: "#9ca3af" },
            },
          },
        },
      });
    }
    
    function updateStatusChart(statusCodes) {
      const ctx = document.getElementById("statusChart");
      if (!ctx) return;
    
      const labels = Object.keys(statusCodes);
      const values = Object.values(statusCodes);
    
      if (labels.length === 0) {
        // No successful responses ‚Üí clear chart if exists
        if (statusChart) {
          statusChart.data.labels = [];
          statusChart.data.datasets[0].data = [];
          statusChart.update();
        }
        return;
      }
    
      if (statusChart) {
        statusChart.data.labels = labels;
        statusChart.data.datasets[0].data = values;
        statusChart.update();
        return;
      }
    
      statusChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              label: "Count",
              data: values,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              display: false,
            },
          },
          scales: {
            x: {
              ticks: { color: "#9ca3af" },
            },
            y: {
              ticks: { color: "#9ca3af" },
            },
          },
        },
      });
    }
    

    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      const url = document.getElementById("url").value;
      const method = document.getElementById("method").value;
      const totalRequests = parseInt(document.getElementById("requests").value, 10);
      const concurrency = parseInt(document.getElementById("concurrency").value, 10);
      const label = document.getElementById("label").value;

      if (!url) return;
      if (totalRequests < 1 || concurrency < 1) return;

      if (isRunning) return;
      setRunningState(true, "normal");
      document.getElementById("live-monitoring").classList.remove("hidden");
      document.getElementById("live-throughput").classList.remove("hidden");

      try {
        const resp = await fetch("/run-test", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            url,
            method,
            total_requests: totalRequests,
            concurrency,
            label,
          }),
        });

        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(text || `HTTP ${resp.status}`);
        }

        const data = await resp.json();
        console.log("Result:", data);

        const runId = data.id;

        // show results area and a live-progress line
        resultsCard.style.display = "block";
        liveProgress.textContent = "Queued ‚Äî waiting for worker...";

        initLiveCharts();
        startChartUpdates();

        // open websocket to receive snapshot + progress + done
        subscribeToRun(runId);

        // also refresh the list in background (final refresh will happen on done)
        loadTests(); // refresh list after a new run
      } catch (err) {
        resultsCard.style.display = "block";
        summaryDiv.innerHTML = `<p style="color:#fca5a5;">Error: ${err.message}</p>`;
        jsonOutput.textContent = "";
      } finally {
        
      }
    });

    runLiveBtn.addEventListener("click", () => {
      runLiveTest();
    });
    

    refreshTestsBtn.addEventListener("click", () => {
      loadTests();
    });

    document.querySelectorAll(".collapsible-header").forEach(header => {
      header.addEventListener("click", () => {
        const target = document.getElementById(header.dataset.target);
        if (!target) return;
    
        target.classList.toggle("hidden");
        header.classList.toggle("collapsed");
      });
    });
    
    async function loadTests() {
      try {
        const resp = await fetch("/tests");
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const tests = await resp.json();
        renderTests(tests);
      } catch (err) {
        console.error("Error loading tests:", err);
      }
    }

    function renderTests(tests) {
      testsCard.style.display = "block";

      if (!tests || tests.length === 0) {
        testsEmpty.style.display = "block";
        testsTable.style.display = "none";
        testsBody.innerHTML = "";
        return;
      }

      testsEmpty.style.display = "none";
      testsTable.style.display = "table";

      testsBody.innerHTML = "";
      tests.forEach((t) => {
        const tr = document.createElement("tr");

        const createdAt = t.created_at
          ? new Date(t.created_at).toLocaleString()
          : "";

        tr.innerHTML = `
          <td>${t.id}</td>
          <td style="max-width:260px;word-break:break-all;">${t.url}</td>
          <td><span class="badge method">${t.method}</span></td>
          <td>${t.total_requests} / ${t.concurrency}</td>
          <td>${createdAt}</td>
          <td>${t.label}</td>
        `;

        tr.addEventListener("click", () => {
          loadTestDetail(t.id);
        });

        testsBody.appendChild(tr);
      });
      
      if (!isRunning && tests.length > 0) {
        loadTestDetail(tests[0].id);
      }
      
    }

    async function loadTestDetail(id) {
      try {
        const resp = await fetch(`/tests/${id}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
    
        renderResult(data);
    
        // üî¥ THIS WAS MISSING
        if (data.metrics?.timeseries) {
          replayTimeSeries(data.metrics.timeseries);
        }
    
      } catch (err) {
        resultsCard.style.display = "block";
        summaryDiv.innerHTML =
          `<p style="color:#fca5a5;">Error loading test ${id}: ${err.message}</p>`;
        jsonOutput.textContent = "";
      }
    }
    

    function getFormConfig() {
      const url = document.getElementById("url").value;
      const method = document.getElementById("method").value;
      const totalRequests = parseInt(document.getElementById("requests").value, 10);
      const concurrency = parseInt(document.getElementById("concurrency").value, 10);
      const label = document.getElementById("label").value;
    
      return { url, method, totalRequests, concurrency, label};
    }
    
    function runLiveTest() {
      const { url, method, totalRequests, concurrency, label } = getFormConfig();
    
      if (!url) return;
      if (totalRequests < 1 || concurrency < 1) return;
    
      const protocol = window.location.protocol === "https:" ? "wss" : "ws";
      const wsUrl = `${protocol}://${window.location.host}/ws/live-test`;
    
      const ws = new WebSocket(wsUrl);
      
      if (isRunning) return;
      setRunningState(true, "live");
      document.getElementById("live-monitoring").classList.remove("hidden");
      document.getElementById("live-throughput").classList.remove("hidden");


      liveProgress.textContent = "";
    
      ws.onopen = () => {
        // send config to server
        ws.send(
          JSON.stringify({
            url,
            method,
            total_requests: totalRequests,
            concurrency,
            label,
          })
        );
        resultsCard.style.display = "block";
        liveProgress.textContent = "Live test started...";
      };
    
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === "progress") {
          const { completed, total } = data;
          const percent = total > 0 ? ((completed / total) * 100).toFixed(1) : 0;
          liveProgress.textContent = `Running: ${completed} / ${total} (${percent}%)`;
        } else if (data.type === "done") {
          const runId = data.run_id;
          liveProgress.textContent = `Completed (Run #${runId}).`;
          setRunningState(false);

          // shape a 'data' object compatible with renderResult
          renderResult({
            url,
            method,
            total_requests: totalRequests,
            concurrency,
            metrics: data.metrics,
          });
    
          // refresh past runs list so this new run appears
          loadTests();
    
          ws.close();
          setRunningState(false);
        } else if (data.type === "error") {
          liveProgress.textContent = `Error: ${data.message}`;
        }
      };
    
      ws.onerror = () => {
        liveProgress.textContent = "WebSocket error.";
        setRunningState(false);
      };
    
      ws.onclose = () => {
        setRunningState(false);
      };
    }

    function handleLiveProgress(payload) {
      if (!payload.timestamp) return;
    
      latencyBuffer.push(payload.avg_latency_ms ?? 0);
      completedBuffer.push(payload.completed ?? 0);
      errorBuffer.push(payload.errors ?? 0);
      timestampBuffer.push(payload.timestamp);
    
      // keep buffers bounded
      if (latencyBuffer.length > 1000) latencyBuffer.shift();
      if (completedBuffer.length > 1000) completedBuffer.shift();
      if (errorBuffer.length > 1000) errorBuffer.shift();
      if (timestampBuffer.length > 1000) timestampBuffer.shift();
    
      const percent =
        payload.total > 0
          ? ((payload.completed / payload.total) * 100).toFixed(1)
          : 0;
    
      liveProgress.textContent =
        `Running: ${payload.completed}/${payload.total} (${percent}%) | ` +
        `Avg latency: ${payload.avg_latency_ms} ms | ` +
        `Errors: ${payload.errors}`;
    }
    
     
    // Subscribe to /ws/run/{runId} to get snapshot, progress and done events.
    function subscribeToRun(runId) {
      const protocol = window.location.protocol === "https:" ? "wss" : "ws";
      const wsUrl = `${protocol}://${window.location.host}/ws/run/${runId}`;
      const ws = new WebSocket(wsUrl);

      // show UI state
      resultsCard.style.display = "block";
      liveProgress.textContent = "Connecting to run " + runId + "...";

      ws.onopen = () => {
        liveProgress.textContent = "Connected. Waiting for updates...";
      };

      ws.onmessage = (event) => {
        // some servers might send raw text; try JSON parse
        let payload;
        try {
          payload = JSON.parse(event.data);
        } catch (err) {
          console.warn("Non-JSON WS payload:", event.data);
          return;
        }

        // handle message types
        if (payload.type === "snapshot") {
          // initial DB snapshot when client connects late
          const snapshot = payload.metrics || {};
          liveProgress.textContent = (snapshot.status || "running");
          // show whatever was persisted so far (if final metrics present, render)
          if (snapshot && snapshot !== "{}" && snapshot !== null) {
            // snapshot may be a metrics object or a wrapper; try to render final if present
            if (snapshot.total_requests || snapshot.requests) {
              // attempt to map snapshot shape to renderResult expectation
              renderResult({
                url: snapshot.url || document.getElementById("url").value,
                method: snapshot.method || document.getElementById("method").value,
                total_requests: snapshot.total_requests || snapshot.total_requests,
                concurrency: snapshot.concurrency || snapshot.concurrency,
                metrics: snapshot,
              });
            }
          }
        } else if (payload.type === "progress") {
          handleLiveProgress(payload);
        } else if (payload.type === "done") {
          liveProgress.textContent = `Completed (Run #${payload.run_id}).`;
          stopChartUpdates();
          // payload.metrics should be the final metrics object
          setRunningState(false);
          loadTestDetail(payload.run_id)
          // update test list now that final results exist
          loadTests();
          ws.close();
        } else if (payload.type === "error") {
          liveProgress.textContent = `Error: ${payload.message || "unknown"}`;
          ws.close();
        } else {
          // fallback: if the server forwarded a raw metrics object
          if (payload.metrics) {
            renderResult(payload);
          }
        }
      };

      ws.onerror = (err) => {
        console.error("WS error", err);
        liveProgress.textContent = "WebSocket error. Check console.";
      };

      ws.onclose = () => {
        // nothing special ‚Äî keep displayed results
        console.log("WS closed for run", runId);
      };

      return ws;
    }

    
    

    function renderResult(data) {
      const summary = data.metrics.summary ?? data.metrics;

      const config = data.config || {
        url: data.url,
        method: data.method,
        total_requests: data.total_requests,
        concurrency: data.concurrency,
        label: data.label
      };

      resultsCard.style.display = "block";

      const lat = summary.latency_ms || {};
      const total = summary.total_requests ?? 0;
      const succ = summary.successful_requests ?? 0;
      const fail = summary.failed_requests ?? 0;
      const rps = summary.requests_per_second ?? 0;

      const statusCodes = summary.status_codes || {};

      let statusHtml = "";
      const entries = Object.entries(statusCodes);
      if (entries.length === 0) {
        statusHtml = "<span class='small'>(no successful responses)</span>";
      } else {
        statusHtml = entries
          .map(([code, count]) => {
            const ok = Number(code) >= 200 && Number(code) < 400;
            const cls = ok ? "ok" : "err";
            return `<span class="status-pill ${cls}">${code}: ${count}</span>`;
          })
          .join(" ");
      }

      summaryDiv.innerHTML = `
        <div class="metrics-grid">
          <div class="metric">
            <div class="metric-label">Target</div>
            <div class="metric-value" style="font-size:0.8rem;word-break:break-all;">${config.url}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Requests</div>
            <div class="metric-value">${total}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Concurrency</div>
            <div class="metric-value">${config.concurrency}</div>
          </div>
          <div class="metric">
            <div class="metric-label">RPS</div>
            <div class="metric-value">${rps.toFixed(2)}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Success / Fail</div>
            <div class="metric-value">${succ} / ${fail}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Avg Latency (ms)</div>
            <div class="metric-value">${lat.avg?.toFixed ? lat.avg.toFixed(2) : lat.avg}</div>
          </div>
          <div class="metric">
            <div class="metric-label">p95 (ms)</div>
            <div class="metric-value">${lat.p95?.toFixed ? lat.p95.toFixed(2) : lat.p95}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Max (ms)</div>
            <div class="metric-value">${lat.max?.toFixed ? lat.max.toFixed(2) : lat.max}</div>
          </div>
        </div>
        <div class="status-codes">
          <div class="metric-label" style="margin-top:0.8rem;">Status Codes</div>
          ${statusHtml}
        </div>
      `;

      updateLatencyChart(lat);
      updateStatusChart(statusCodes);

      jsonOutput.textContent = JSON.stringify(data, null, 2);
    }

    // initial load
    loadTests();
  </script>
</body>
</html>
